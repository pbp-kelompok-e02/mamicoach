{% extends "base_chat.html" %}

{% block title %}Chat{% endblock %}

{% block content %}
<div class="flex h-screen bg-gray-100 min-h-0">
    <!-- Sessions Sidebar -->
    <div id="sessions-sidebar" class="w-full md:w-1/3 lg:w-1/4 bg-white border-r border-gray-200 flex flex-col {% if selected_session_id %}hidden md:flex{% endif %} min-h-0">
        <!-- Sessions Header -->
        <div class="flex-shrink-0 bg-primary text-white p-4">
            <div class="flex items-center justify-between">
                <h1 class="text-xl font-semibold">Chats</h1>
                <button id="search-toggle" class="p-2 hover:bg-white/10 rounded-lg transition-colors">
                    <svg xmlns="http://www.w3.org/2000/svg" class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" stroke-width="2">
                        <circle cx="11" cy="11" r="8"/>
                        <path d="m21 21-4.35-4.35"/>
                    </svg>
                </button>
            </div>
            
            <!-- Search Bar -->
            <div id="search-container" class="mt-3 hidden">
                <div class="relative">
                    <input
                        type="text"
                        id="session-search"
                        placeholder="Search conversations..."
                        class="w-full bg-white/10 text-white placeholder-white/70 rounded-lg px-4 py-2 focus:outline-none focus:bg-white/20"
                    >
                    <svg xmlns="http://www.w3.org/2000/svg" class="w-4 h-4 absolute right-3 top-3 text-white/70" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <circle cx="11" cy="11" r="8"/>
                        <path d="m21 21-4.35-4.35"/>
                    </svg>
                </div>
            </div>
        </div>

        <!-- Sessions List -->
        <div class="flex-1 overflow-y-auto">
            <div id="sessions-loading" class="text-center py-8 text-gray-500">
                Loading conversations...
            </div>
            <div id="sessions-list" class="divide-y divide-gray-100">
                <!-- Sessions will be loaded here -->
            </div>
        </div>
    </div>

    <!-- Chat Panel -->
    <div id="chat-panel" class="flex-1 h-full flex flex-col {% if not selected_session_id %}hidden md:flex{% endif %} min-h-0">
        {% if selected_session_id %}
            <!-- Chat Header -->
            <header class="bg-white border-b border-gray-200 px-4 py-3 flex-shrink-0 z-10">
                <div class="flex items-center">
                    <!-- Back Button for Mobile -->
                    <button id="back-to-sessions" class="md:hidden mr-3 p-2 hover:bg-gray-100 rounded-lg transition-colors">
                        <svg xmlns="http://www.w3.org/2000/svg" class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" stroke-width="2">
                            <path d="m15 18-6-6 6-6"/>
                        </svg>
                    </button>
                    
                    <div class="flex items-center space-x-3">
                        <div class="w-10 h-10 bg-primary text-white rounded-full flex items-center justify-center font-semibold">
                            {{ other_user.first_name.0|upper|default:"U" }}{{ other_user.last_name.0|upper|default:"" }}
                        </div>
                        <div>
                            <h2 class="font-semibold text-gray-900">
                                {{ other_user.first_name }} {{ other_user.last_name }}
                            </h2>
                        </div>
                    </div>
                </div>
            </header>

            <!-- Messages Container -->
            <main id="messages-container" class="flex-1 overflow-y-auto p-4 bg-gray-50 min-h-0">
                <div id="messages-loading" class="text-center py-8 text-gray-500">
                    Loading messages...
                </div>
                <div id="messages-list">
                    <!-- Messages will be loaded here -->
                </div>
            </main>

            <!-- Message Input -->
            <footer class="bg-white border-t border-gray-200 p-4 flex-shrink-0 z-10">
                <form id="message-form" class="flex items-end space-x-3 gap-2">
                    <div class="flex-1 flex flex-col items-center">
                        <textarea
                            id="message-input"
                            placeholder="Type a message..."
                            rows="1"
                            class="w-full px-4 py-2 border border-gray-300 rounded-2xl focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent resize-none"
                        ></textarea>
                    </div>
                    <button
                        type="submit"
                        id="send-button"
                        disabled
                        class="bg-primary text-white p-3 rounded-full hover:bg-primary-dark focus:outline-none focus:ring-2 focus:ring-primary disabled:opacity-50 disabled:cursor-not-allowed transition-colors flex-shrink-0 flex flex-col items-center justify-center"
                    >
                        <svg xmlns="http://www.w3.org/2000/svg" class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" stroke-width="2">
                            <path d="m22 2-7 20-4-9-9-4Z"/>
                            <path d="M22 2 11 13"/>
                        </svg>
                    </button>
                </form>
            </footer>
        {% else %}
            <!-- No Chat Selected State -->
            <div class="hidden md:flex flex-1 items-center justify-center bg-gray-50">
                <div class="text-center">
                    <div class="w-24 h-24 bg-gray-200 rounded-full flex items-center justify-center mx-auto mb-4">
                        <svg xmlns="http://www.w3.org/2000/svg" class="w-12 h-12 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/>
                        </svg>
                    </div>
                    <h3 class="text-xl font-semibold text-gray-700 mb-2">Welcome to MamiCoach Chat</h3>
                    <p class="text-gray-500">Select a conversation to start messaging</p>
                </div>
            </div>
        {% endif %}
    </div>
</div>

<script>
const selectedSessionId = {% if selected_session_id %}'{{ selected_session_id }}'{% else %}null{% endif %};
let pollInterval;
let isWindowActive = true;
let markReadTimeout;
let pendingMarkReadSessionId = null;

// Local storage keys
const MARK_READ_KEY_PREFIX = 'chat_marked_read_';

function getLastMarkedReadTime(sessionId) {
    return localStorage.getItem(MARK_READ_KEY_PREFIX + sessionId);
}

function setLastMarkedReadTime(sessionId, timestamp) {
    localStorage.setItem(MARK_READ_KEY_PREFIX + sessionId, timestamp);
}

document.addEventListener('DOMContentLoaded', async function() {
    await loadSessions();
    
    // If we have a selected session, load its messages
    if (selectedSessionId) {
        await loadMessages(selectedSessionId);
        setupMessageInput();
    }
    
    // Search functionality
    setupSearch();
    
    // Mobile navigation
    setupMobileNavigation();
    
    // Start polling for new conversations
    startPollingConversations();
    
    // Track window focus
    setupWindowFocusTracking();
});

// Track when window is active/inactive
function setupWindowFocusTracking() {
    window.addEventListener('focus', async function() {
        isWindowActive = true;
        // Refresh immediately when window regains focus
        await loadSessions();
        if (selectedSessionId) {
            await loadMessages(selectedSessionId, true);
        }
    });
    
    window.addEventListener('blur', function() {
        isWindowActive = false;
    });
}

// Poll for new conversations every 3 seconds (only when window is active)
function startPollingConversations() {
    pollInterval = setInterval(async () => {
        if (isWindowActive) {
            await loadSessions();
            
            // Also refresh current chat messages if a session is selected
            // skipScroll = true to preserve user's scroll position during polling
            if (selectedSessionId) {
                await loadMessages(selectedSessionId, true);
            }
        }
    }, 3000);
}

// Stop polling when page unloads
window.addEventListener('beforeunload', function() {
    if (pollInterval) {
        clearInterval(pollInterval);
    }
});

// Load and display sessions
async function loadSessions() {
    try {
        const response = await fetch('{% url "chat:get_chat_sessions" %}');
        const data = await response.json();
        
        const container = document.getElementById('sessions-list');
        const loading = document.getElementById('sessions-loading');
        
        if (loading) loading.style.display = 'none';
        
        if (data.sessions && data.sessions.length > 0) {
            container.innerHTML = data.sessions.map(createSessionItem).join('');
        } else {
            container.innerHTML = '<div class="text-center text-gray-500 py-8">No conversations yet</div>';
        }
    } catch (error) {
        console.error('Error loading sessions:', error);
        const loading = document.getElementById('sessions-loading');
        if (loading) loading.textContent = 'Error loading conversations';
    }
}

// Helper function to format timestamp with date if yesterday or older
function formatMessageTime(timestamp) {
    const messageDate = new Date(timestamp);
    const today = new Date();
    const yesterday = new Date(today);
    yesterday.setDate(yesterday.getDate() - 1);
    
    // Check if message is from today
    if (messageDate.toDateString() === today.toDateString()) {
        return messageDate.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
    }
    
    // Check if message is from yesterday
    if (messageDate.toDateString() === yesterday.toDateString()) {
        return 'Yesterday ' + messageDate.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
    }
    
    // For older messages, show date and time
    return messageDate.toLocaleDateString([], {month: 'short', day: 'numeric'}) + ' ' + 
           messageDate.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
}

function createSessionItem(session) {
    const isSelected = selectedSessionId === session.id;
    const lastMessageTime = session.last_message.timestamp ? 
        formatMessageTime(session.last_message.timestamp) : '';
    
    const otherUserName = `${session.other_user.first_name} ${session.other_user.last_name}`.trim() || session.other_user.username;
    const userInitial = session.other_user.first_name ? session.other_user.first_name.charAt(0).toUpperCase() : 
                        session.other_user.username.charAt(0).toUpperCase();
    
    return `
        <div class="session-item p-4 hover:bg-gray-50 cursor-pointer transition-colors ${isSelected ? 'bg-blue-50 border-r-4 border-primary' : ''}" 
             data-session-id="${session.id}">
            <div class="flex items-start space-x-3">
                <div class="w-12 h-12 bg-primary text-white rounded-full flex items-center justify-center font-semibold flex-shrink-0">
                    ${userInitial}
                </div>
                <div class="flex-1 min-w-0">
                    <div class="flex justify-between items-start">
                        <h3 class="font-semibold text-gray-900 truncate">${DOMPurify.sanitize(otherUserName)}</h3>
                        <span class="text-xs text-gray-500 flex-shrink-0 ml-2">${lastMessageTime}</span>
                    </div>
                    <div class="flex justify-between items-center mt-1">
                        <p class="text-sm text-gray-600 truncate flex-1">
                            ${session.last_message.content ? DOMPurify.sanitize(session.last_message.content) : 'No messages yet'}
                        </p>
                        ${session.unread_count > 0 ? 
                            `<span class="bg-primary text-white text-xs font-semibold px-2 py-1 rounded-full flex-shrink-0 ml-2">${session.unread_count}</span>` : ''}
                    </div>
                </div>
            </div>
        </div>
    `;
}

// Handle session selection
document.addEventListener('click', function(e) {
    const sessionItem = e.target.closest('.session-item');
    if (sessionItem) {
        const sessionId = sessionItem.dataset.sessionId;
        // Navigate to the session URL
        window.location.href = `{% url 'chat:chat_detail' session_id='00000000-0000-0000-0000-000000000000' %}`.replace('00000000-0000-0000-0000-000000000000', sessionId);
    }
});

// Load messages for selected session
async function loadMessages(sessionId, skipScroll = false) {
    const container = document.getElementById('messages-list');
    const loading = document.getElementById('messages-loading');
    
    try { 
        const response = await fetch(`{% url 'chat:get_messages' session_id='00000000-0000-0000-0000-000000000000' %}`.replace('00000000-0000-0000-0000-000000000000', sessionId));
        const data = await response.json();
        
        if (loading) loading.style.display = 'none';
        
        if (data.messages && data.messages.length > 0) {
            // On initial load, rebuild entire DOM
            if (!skipScroll) {
                container.innerHTML = data.messages.map(createMessageItem).join('');
                // Scroll to bottom after DOM is rendered
                await new Promise(resolve => setTimeout(resolve, 0));
                scrollToBottom();
            } else {
                // During polling, only update changed messages
                updateMessagesIncrementally(container, data.messages);
            }
        } else {
            if (!skipScroll) {
                container.innerHTML = '<div class="text-center text-gray-500 py-8">No messages yet. Start the conversation!</div>';
                await new Promise(resolve => setTimeout(resolve, 0));
                scrollToBottom();
            }
        }
        
        // Setup scroll event listener for marking as read
        setupScrollToRead();
        
        // Debounced mark as read since we're viewing the messages
        debouncedMarkMessagesAsRead(sessionId);
    } catch (error) {
        console.error('Error loading messages:', error);
        if (loading) {
            loading.textContent = 'Error loading messages';
            loading.style.display = 'block';
        } else {
            container.innerHTML = '<div class="text-center text-red-500 py-8">Error loading messages. Please try again.</div>';
        }
    }
}

// Update messages incrementally without full DOM rebuild
function updateMessagesIncrementally(container, newMessages) {
    // Get all current message elements (each message has data-message-id)
    const existingMessages = new Map();
    container.querySelectorAll('[data-message-id]').forEach(el => {
        existingMessages.set(el.dataset.messageId, el);
    });
    
    // Track which message IDs we've seen
    const newMessageIds = new Set(newMessages.map(msg => msg.id));
    
    // Remove messages that no longer exist
    existingMessages.forEach((el, id) => {
        if (!newMessageIds.has(id)) {
            el.remove();
        }
    });
    
    // Add new messages or update existing ones
    newMessages.forEach((message, index) => {
        const existingEl = existingMessages.get(message.id);
        
        if (existingEl) {
            // Update existing message (mainly for read status)
            const readIndicator = existingEl.querySelector('[data-read-status]');
            if (readIndicator && message.read) {
                readIndicator.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" class="w-3 h-3 ml-1 text-blue-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 6 7 17l-5-5"/><path d="m22 10-7.5 7.5L13 16"/></svg>';
            }
        } else {
            // Add new message - insert in correct position
            const messageHtml = createMessageItemWithId(message);
            
            // Find the correct position to insert
            if (index === newMessages.length - 1) {
                // Last message - append at end
                container.insertAdjacentHTML('beforeend', messageHtml);
            } else {
                // Find the next message that exists and insert before it
                let inserted = false;
                for (let i = index + 1; i < newMessages.length; i++) {
                    const nextExisting = existingMessages.get(newMessages[i].id);
                    if (nextExisting) {
                        nextExisting.insertAdjacentHTML('beforebegin', messageHtml);
                        inserted = true;
                        break;
                    }
                }
                if (!inserted) {
                    container.insertAdjacentHTML('beforeend', messageHtml);
                }
            }
        }
    });
}

function createMessageItem(message) {
    const isOwn = message.is_sent_by_me;
    const messageTime = formatMessageTime(message.timestamp);
    
    return `
        <div class="mb-4 flex ${isOwn ? 'justify-end' : 'justify-start'}" data-message-id="${message.id}">
            <div>
                <div class="max-w-xs lg:max-w-md ${isOwn ? 'bg-primary text-white' : 'bg-white text-gray-900'} rounded-2xl px-4 py-2 shadow-sm">
                    <p class="break-words">${DOMPurify.sanitize(message.content)}</p>
                </div>
                <div class="flex ${isOwn ? 'justify-end' : 'justify-start'} mt-1">
                    <span class="text-xs text-gray-500 flex items-center">
                        ${messageTime}
                        ${isOwn ? (message.read ? 
                            '<svg xmlns="http://www.w3.org/2000/svg" class="w-3 h-3 ml-1 text-blue-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-read-status><path d="M18 6 7 17l-5-5"/><path d="m22 10-7.5 7.5L13 16"/></svg>' : 
                            '<svg xmlns="http://www.w3.org/2000/svg" class="w-3 h-3 ml-1" fill="none" stroke="currentColor" viewBox="0 0 24 24" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-read-status><path d="M20 6 9 17l-5-5"/></svg>') : ''}
                    </span>
                </div>
            </div>
        </div>
    `;
}

function createMessageItemWithId(message) {
    return createMessageItem(message);
}

function setupMessageInput() {
    const messageInput = document.getElementById('message-input');
    const messageForm = document.getElementById('message-form');
    const sendButton = document.getElementById('send-button');
    
    if (messageInput) {
        messageInput.addEventListener('input', function() {
            sendButton.disabled = this.value.trim() === '';
            
            // Auto-resize textarea
            this.style.height = 'auto';
            this.style.height = Math.min(this.scrollHeight, 120) + 'px';
        });
        
        messageInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                if (this.value.trim()) {
                    sendMessage(selectedSessionId);
                }
            }
        });
        
        sendButton.disabled = messageInput.value.trim() === '';
        messageInput.focus();
    }
    
    if (messageForm) {
        messageForm.addEventListener('submit', function(e) {
            e.preventDefault();
            if (messageInput.value.trim()) {
                sendMessage(selectedSessionId);
            }
        });
    }
}

async function sendMessage(sessionId) {
    const messageInput = document.getElementById('message-input');
    const sendButton = document.getElementById('send-button');
    const content = messageInput.value.trim();
    
    if (!content) return;
    
    messageInput.disabled = true;
    sendButton.disabled = true;
    
    try {
        const response = await fetch('{% url "chat:send_message" %}', {
            method: 'POST',
            body: JSON.stringify({
                session_id: sessionId,
                content: content
            })
        });
        
        const data = await response.json();
        
        if (data.success) {
            messageInput.value = '';
            messageInput.style.height = 'auto';
            
            const messagesContainer = document.getElementById('messages-list');
            const messageHtml = createMessageItem({
                ...data.message,
                is_sent_by_me: true
            });
            messagesContainer.insertAdjacentHTML('beforeend', messageHtml);
            scrollToBottom();
            
            // Refresh sessions to update last message and clear unread badges
            await loadSessions();
        } else {
            alert('Error sending message: ' + (data.error || 'Unknown error'));
        }
    } catch (error) {
        console.error('Error sending message:', error);
        alert('Error sending message. Please try again.');
    } finally {
        messageInput.disabled = false;
        sendButton.disabled = messageInput.value.trim() === '';
        messageInput.focus();
    }
}

async function markMessagesAsRead(sessionId) {
    try {
        await fetch('{% url "chat:mark_messages_read" %}', {
            method: 'POST',
            body: JSON.stringify({
                session_id: sessionId
            })
        });
    } catch (error) {
        console.error('Error marking messages as read:', error);
    }
}

// Debounced version of markMessagesAsRead to prevent spam
function debouncedMarkMessagesAsRead(sessionId) {
    // Clear existing timeout
    if (markReadTimeout) {
        clearTimeout(markReadTimeout);
    }
    
    // Store the session ID
    pendingMarkReadSessionId = sessionId;
    
    // Set a new timeout to mark as read after 1 second of inactivity
    markReadTimeout = setTimeout(() => {
        if (pendingMarkReadSessionId) {
            const lastMarked = getLastMarkedReadTime(pendingMarkReadSessionId);
            const now = new Date().getTime();
            
            // Only call API if we haven't marked this session as read in the last 5 seconds
            if (!lastMarked || (now - parseInt(lastMarked)) > 5000) {
                markMessagesAsRead(pendingMarkReadSessionId);
                setLastMarkedReadTime(pendingMarkReadSessionId, now);
            }
            pendingMarkReadSessionId = null;
        }
    }, 1000);
}

function setupSearch() {
    const searchToggle = document.getElementById('search-toggle');
    const searchContainer = document.getElementById('search-container');
    const searchInput = document.getElementById('session-search');
    
    if (searchToggle) {
        searchToggle.addEventListener('click', function() {
            searchContainer.classList.toggle('hidden');
            if (!searchContainer.classList.contains('hidden')) {
                searchInput.focus();
            }
        });
    }
    
    if (searchInput) {
        searchInput.addEventListener('input', function() {
            filterSessions(this.value.toLowerCase());
        });
    }
}

function filterSessions(query) {
    const sessionItems = document.querySelectorAll('.session-item');
    sessionItems.forEach(item => {
        const userName = item.querySelector('h3').textContent.toLowerCase();
        const lastMessage = item.querySelector('p').textContent.toLowerCase();
        
        if (userName.includes(query) || lastMessage.includes(query)) {
            item.style.display = 'block';
        } else {
            item.style.display = 'none';
        }
    });
}

function setupMobileNavigation() {
    const backButton = document.getElementById('back-to-sessions');
    const sessionsSidebar = document.getElementById('sessions-sidebar');
    const chatPanel = document.getElementById('chat-panel');
    
    if (backButton) {
        backButton.addEventListener('click', function() {
            // Navigate back to main chat page
            window.location.href = '{% url "chat:chat_index" %}';
        });
    }
}

function scrollToBottom() {
    const container = document.getElementById('messages-container');
    if (container) {
        // Use setTimeout to ensure DOM has fully rendered
        setTimeout(() => {
            container.scrollTop = container.scrollHeight;
        }, 0);
    }
}

function setupScrollToRead() {
    const messagesContainer = document.getElementById('messages-container');
    if (messagesContainer) {
        messagesContainer.addEventListener('scroll', function() {
            // Check if scrolled to bottom (within 100px)
            const isAtBottom = messagesContainer.scrollHeight - messagesContainer.scrollTop - messagesContainer.clientHeight < 100;
            
            if (isAtBottom && selectedSessionId) {
                // Debounced mark messages as read
                debouncedMarkMessagesAsRead(selectedSessionId);
            }
        });
    }
}
</script>
{% endblock %}